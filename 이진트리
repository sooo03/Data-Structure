'''
n개의 노드로 구성된 이진트리를 세 개의 리스트에 저장한다.
노드 번호는 1부터 n 사이의 정수로 노드의 key 값을 의미한다.
parent[v]에는 v의 부모 노드 번호를 저장한다.
left[v]와 right[v]는 각각 v의 왼쪽과 오른쪽 자식노드가 저장된다.
부모노드와 자식노드가 없을 때에는 0이 저장된다.
리스트에 저장하지 않고 트리의 Node 클래스를 선언해서 표현해도 된다.
[입력]
-첫 줄: 노드 개수 n (1<=n<=10000)
-두 번째 줄부터 각 노드 v와 v의 두 자식 노드의 정보가 주어진다.
-v 1 r 인 경우, v의 왼쪽과 오른쪽 자식노드가 각각 1과 r이다. 만약, 해당 자식노드가 없다면 0
'''
'''
is_ancestor(u, v): u가 v의 조상노드이면 True, 아니면 False 리턴
depth(v): v의 깊이를 리턴(루트노드의 깊이는 0이고, 레벨이 하나 증가할 때마다 깊이는 1 증가)
preorder(v), postorder(v): 각각 v의 preorder와 postorder의 방문 시간을 리턴(루트노드의 방문 시간은 1로 가정)
lca(u, v): u와 v의 LCA(Lowest Common Ancestor) 노드 번호를 리턴
'''

# preorder, postorder 빼고는 다 맞음
class Node:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None

    def __str__(self):
        return str(self.key)

    def preorder(self):
        node = nodes[self.key]
        traversal=[]
        def traverse(node):
            if node == None:
                return
            traversal.append(node.key)
            traverse(node.left)
            traverse(node.right)
        traverse(node)
        return traversal

    def postorder(self):
        node = nodes[self.key]
        traversal=[]
				
        def traverse(node):
            if node == None:
                return
            traverse(node.left)
            traverse(node.right)
            traversal.append(node.key)
        traverse(node)
        return traversal
            
    def depth(self):
        if self.parent is None:
            return 0
        return self.parent.depth() + 1

    def is_ancestor(self, u, v):
        node_u = self.find_node(u)
        node_v = self.find_node(v)
        if node_u == None or node_v == None:
            return False
        
        ancestors = set()
        while node_u:
            ancestors.add(node_u)
            node_u = node_u.parent
        while node_v:
            if node_v in ancestors:
                return True
            node_v = node_v.parent
        return False

    def find_node(self, key):
        if self == None:
            return None
        if self.key == key:
            return self
        left_result = self.left.find_node(key) if self.left else None
        if left_result:
            return left_result
        right_result = self.right.find_node(key) if self.right else None
        if right_result:
            return right_result
        return None

    def lca(self, u, v):
        if self == None:
            return None
        if self.key == u or self.key == v:
            return self
        left_lca = self.left.lca(u, v) if self.left else None
        right_lca = self.right.lca(u, v) if self.right else None
        if left_lca and right_lca:
            return self
        if left_lca:
            return left_lca
        if right_lca:
            return right_lca
        return None


n = int(input())  # 노드의 개수

nodes = {}
for i in range(1, n+1):
    nodes[i] = Node(i)

for i in range(n):
    node_info = list(map(int, input().split()))
    v = node_info[0]
    left_child = node_info[1]
    right_child = node_info[2]

    node = nodes[v]
    if left_child != 0:
        node.left = nodes[left_child]
        nodes[left_child].parent = node
    if right_child != 0:
        node.right = nodes[right_child]
        nodes[right_child].parent = node


def preorder(v):
    return nodes[v].preorder()
def postorder(v):
    return nodes[v].postorder()
def depth(v):
    return nodes[v].depth()
def is_ancestor(u, v):
    return nodes[u].is_ancestor(u, v)
def lca(u, v):
    node_u = nodes[u]
    node_v = nodes[v]
    while node_u != node_v:
        if node_u.depth() > node_v.depth():
            node_u = node_u.parent
        elif node_u.depth() < node_v.depth():
            node_v = node_v.parent
        else:
            node_u = node_u.parent
            node_v = node_v.parent
    return node_u.key


while True:
    cmd = input().split()
    if cmd[0] == 'exit':
        break
    elif cmd[0] == 'preorder':
        res = preorder(int(cmd[1]))
        print(f"  > preorder({int(cmd[1])}) = {res}")
    elif cmd[0] == 'postorder':
        res = postorder(int(cmd[1]))
        print(f"  > postorder({int(cmd[1])}) = {res}")
    elif cmd[0] == 'depth':
        res = depth(int(cmd[1]))
        print(f"  > depth({int(cmd[1])}) = {res}")
    elif cmd[0] == 'is_ancestor':
        res = is_ancestor(int(cmd[1]), int(cmd[2]))
        print(f"  > {int(cmd[1])} is {'an' if res else 'not an'} ancestor of {int(cmd[2])}")
    elif cmd[0] == 'lca':
        res = lca(int(cmd[1]), int(cmd[2]))
        print(f"  > lca({int(cmd[1])}, {int(cmd[2])}) = {res}")
    else:
        print("illegal command")
